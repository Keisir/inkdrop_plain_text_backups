{"version":3,"sources":["../src/utilities.js"],"names":["self","module","exports","dataMap","books","notes","tree","disposable","getBackupPath","inkdrop","config","get","core","db","backupPath","getPlainTextPath","getDataMapPath","plainTextPath","getNotePath","getDataMap","JSON","parse","fs","promises","readFile","writeNote","notePath","body","mkdir","path","dirname","recursive","writeFile","getBookPath","doc","bookPath","name","parentBookId","hasParent","parentBookData","Boolean","getDataAndWriteAllNotes","allNotes","all","Promise","resolve","reject","docs","map","_id","title","bookData","bookId","getTree","dirPath","arrayOfFiles","files","readdirSync","forEach","file","filePath","statSync","isDirectory","extname","push","writeMaps","maps","dataMapPath","stringify","importAll","diskDataMap","main","dataStore","getLocalDB","Object","keys","noteId","fileTreeIndex","indexOf","console","log","splice","newBody","currentNote","put","_rev","updatedAt","Date","now","doctype","createdAt","err","warn","prunedTree","filter","RegExp","test","newNotePath","bookPathArray","replace","split","bookDoc","findWithName","pop","newNoteId","createId","basename"],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\nimport * as path from \"path\";\n\nconst self = (module.exports = {\n    dataMap: { books: {}, notes: {}, tree: [] },\n    disposable: null,\n\n    getBackupPath() {\n        return inkdrop.config.get().core.db.backupPath;\n    },\n    getPlainTextPath(backupPath) {\n        return `${backupPath || self.getBackupPath()}/PLAIN_TEXT`;\n    },\n    getDataMapPath(plainTextPath) {\n        return `${\n            plainTextPath || self.getPlainTextPath()\n        }/.inkdrop_plain_text_backups/__DATA_MAP__.json`;\n    },\n    getNotePath() {},\n\n    async getDataMap(plainTextPath) {\n        return JSON.parse(\n            await fs.promises.readFile(\n                self.getDataMapPath(plainTextPath),\n                \"utf-8\"\n            )\n        );\n    },\n\n    async writeNote(notePath, body) {\n        await fs.promises.mkdir(path.dirname(notePath), { recursive: true });\n        await fs.promises.writeFile(notePath, body);\n    },\n    async getBookPath(disposable, doc) {\n        let bookPath = doc.name;\n        if (doc.parentBookId) {\n            let hasParent = true;\n            while (hasParent) {\n                var parentBookData = await disposable.books.get(\n                    parentBookData\n                        ? parentBookData.parentBookId\n                        : doc.parentBookId\n                );\n                bookPath = `${parentBookData.name}/${bookPath}`;\n                hasParent = Boolean(parentBookData.parentBookId);\n            }\n        }\n        return bookPath;\n    },\n    async getDataAndWriteAllNotes(disposable, plainTextPath) {\n        // Sync everything one time:\n        const allNotes = await disposable.notes.all();\n\n        return new Promise(async (resolve, reject) => {\n            await Promise.all(\n                await allNotes.docs.map(async (doc) => {\n                    if (!self.dataMap.notes[doc._id]) {\n                        self.dataMap.notes[doc._id] = {};\n                    }\n                    self.dataMap.notes[doc._id].title = doc.title;\n\n                    const bookData = await disposable.books.get(doc.bookId);\n\n                    if (bookData) {\n                        let bookPath = await self.getBookPath(\n                            disposable,\n                            bookData\n                        );\n\n                        self.dataMap.books[doc.bookId] = bookPath;\n                        self.dataMap.notes[\n                            doc._id\n                        ].path = `${bookPath}/${doc.title}.md`;\n\n                        await self.writeNote(\n                            `${plainTextPath}/${\n                                self.dataMap.notes[doc._id].path\n                            }`,\n                            doc.body\n                        );\n                    }\n                })\n            );\n            if (self.dataMap) {\n                resolve(self.dataMap);\n            } else {\n                reject(self);\n            }\n        });\n    },\n    getTree: (dirPath, arrayOfFiles) => {\n        const files = fs.readdirSync(dirPath);\n\n        arrayOfFiles = arrayOfFiles || [];\n\n        files.forEach(function (file) {\n            const filePath = `${dirPath}/${file}`;\n            if (fs.statSync(filePath).isDirectory()) {\n                arrayOfFiles = self.getTree(filePath, arrayOfFiles);\n            } else if (path.extname(file) === \".md\") {\n                arrayOfFiles.push(filePath);\n            }\n        });\n\n        return arrayOfFiles;\n    },\n    async writeMaps(plainTextPath, maps) {\n        maps.tree = self.getTree(plainTextPath);\n        const dataMapPath = self.getDataMapPath(plainTextPath);\n        await fs.promises.mkdir(path.dirname(dataMapPath), { recursive: true });\n\n        await fs.promises.writeFile(dataMapPath, JSON.stringify(maps));\n    },\n\n    async importAll() {\n        const plainTextPath = self.getPlainTextPath();\n        const diskDataMap = await self.getDataMap(plainTextPath);\n        self.disposable =\n            self.disposable || inkdrop.main.dataStore.getLocalDB();\n\n        const tree = self.getTree(plainTextPath);\n\n        await Promise.all(\n            Object.keys(diskDataMap.notes).map(async (noteId) => {\n                const filePath = `${plainTextPath}/${diskDataMap.notes[noteId].path}`;\n                const fileTreeIndex = tree.indexOf(filePath);\n                console.log(filePath);\n                if (fileTreeIndex > -1) {\n                    tree.splice(fileTreeIndex, 1);\n                }\n                const newBody = await fs.promises.readFile(filePath, \"utf-8\");\n\n                try {\n                    const currentNote = await self.disposable.notes.get(noteId);\n\n                    // Don't bother if there are no changes:\n                    if (currentNote.body !== newBody) {\n                        await self.disposable.notes.put({\n                            _id: noteId,\n                            _rev: currentNote._rev,\n                            updatedAt: Date.now(),\n                            bookId: currentNote.bookId,\n                            title: currentNote.title,\n                            doctype: currentNote.doctype,\n                            createdAt: currentNote.createdAt,\n                            body: newBody,\n                        });\n                    }\n                } catch (err) {\n                    console.warn(\n                        `${noteId} import from plain text failed!`,\n                        err\n                    );\n                }\n            })\n        );\n\n        // Remove 'Trash' files from the tree:\n        const prunedTree = tree.filter((filePath) => {\n            return !new RegExp(`${plainTextPath}/undefined/`).test(filePath);\n        });\n\n        console.log(tree, prunedTree);\n\n        await Promise.all(\n            prunedTree.map(async (newNotePath) => {\n                const bookPathArray = path\n                    .dirname(newNotePath)\n                    .replace(new RegExp(`^${plainTextPath}/`), \"\")\n                    .split(\"/\");\n                // This is a best guess because it uses the name,\n                // if there is another notebook with the same\n                // exact name this may return the\n                // 'wrong' one.\n                const bookDoc = await self.disposable.books.findWithName(\n                    bookPathArray.pop()\n                );\n                if (bookDoc && bookDoc._id) {\n                    const newBody = await fs.promises.readFile(\n                        newNotePath,\n                        \"utf-8\"\n                    );\n\n                    const newNoteId = self.disposable.notes.createId();\n                    await self.disposable.notes.put({\n                        _id: newNoteId,\n                        updatedAt: Date.now(),\n                        bookId: bookDoc._id,\n                        title: path\n                            .basename(newNotePath)\n                            .replace(\n                                new RegExp(`${path.extname(newNotePath)}$`),\n                                \"\"\n                            ),\n                        doctype: \"markdown\",\n                        createdAt: Date.now(),\n                        body: newBody,\n                    });\n                }\n            })\n        );\n\n        await self.writeMaps(plainTextPath, self.dataMap);\n    },\n});\n"],"file":"utilities.js"}