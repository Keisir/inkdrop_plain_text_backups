{"version":3,"sources":["../src/utilities.js"],"names":["self","module","exports","dataMap","books","notes","tree","getBackupPath","inkdrop","config","get","core","db","backupPath","getPlainTextPath","getDataMapPath","plainTextPath","getNotePath","getDataMap","JSON","parse","fs","promises","readFile","writeNote","notePath","body","mkdir","path","dirname","recursive","writeFile","getBookPath","disposable","doc","bookPath","name","parentBookId","hasParent","parentBookData","Boolean","getDataAndWriteAllNotes","allNotes","all","Promise","resolve","reject","docs","map","_id","title","bookData","bookId","treePaths","currentDir","getTree","source","initialRead","readdir","withFileTypes","filter","dirent","isDirectory","isFile","test","subDirents","join","directory","children","push","file","exists","getAllFiles","dirPath","arrayOfFiles","files","readdirSync","forEach","filePath","statSync","writeMaps","maps","console","log","dataMapPath","stringify","importAll","diskDataMap","main","dataStore","getLocalDB","Object","keys","noteId","newBody","currentNote","put","_rev","updatedAt","Date","now","doctype","createdAt","err","warn","dispose"],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\nimport * as path from \"path\";\n\nconst self = (module.exports = {\n    dataMap: { books: {}, notes: {}, tree: [] },\n\n    getBackupPath() {\n        return inkdrop.config.get().core.db.backupPath;\n    },\n    getPlainTextPath(backupPath) {\n        return `${backupPath || self.getBackupPath()}/PLAIN_TEXT`;\n    },\n    getDataMapPath(plainTextPath) {\n        return `${\n            plainTextPath || self.getPlainTextPath()\n        }/.inkdrop_plain_text_backups/__DATA_MAP__.json`;\n    },\n    getNotePath() {},\n\n    async getDataMap(plainTextPath) {\n        return JSON.parse(\n            await fs.promises.readFile(\n                self.getDataMapPath(plainTextPath),\n                \"utf-8\"\n            )\n        );\n    },\n\n    async writeNote(notePath, body) {\n        await fs.promises.mkdir(path.dirname(notePath), { recursive: true });\n        await fs.promises.writeFile(notePath, body);\n    },\n    async getBookPath(disposable, doc) {\n        let bookPath = doc.name;\n        if (doc.parentBookId) {\n            let hasParent = true;\n            while (hasParent) {\n                var parentBookData = await disposable.books.get(\n                    parentBookData\n                        ? parentBookData.parentBookId\n                        : doc.parentBookId\n                );\n                bookPath = `${parentBookData.name}/${bookPath}`;\n                hasParent = Boolean(parentBookData.parentBookId);\n            }\n        }\n        return bookPath;\n    },\n    async getDataAndWriteAllNotes(disposable, plainTextPath) {\n        // Sync everything one time:\n        const allNotes = await disposable.notes.all();\n\n        return new Promise(async (resolve, reject) => {\n            await Promise.all(\n                await allNotes.docs.map(async (doc) => {\n                    if (!self.dataMap.notes[doc._id]) {\n                        self.dataMap.notes[doc._id] = {};\n                    }\n                    self.dataMap.notes[doc._id].title = doc.title;\n\n                    const bookData = await disposable.books.get(doc.bookId);\n\n                    if (bookData) {\n                        let bookPath = await self.getBookPath(\n                            disposable,\n                            bookData\n                        );\n\n                        self.dataMap.books[doc.bookId] = bookPath;\n                        self.dataMap.notes[\n                            doc._id\n                        ].path = `${bookPath}/${doc.title}.md`;\n\n                        await self.writeNote(\n                            `${plainTextPath}/${\n                                self.dataMap.notes[doc._id].path\n                            }`,\n                            doc.body\n                        );\n                    }\n                })\n            );\n            if (self.dataMap) {\n                resolve(self.dataMap);\n            } else {\n                reject(self);\n            }\n        });\n    },\n    treePaths: [],\n    currentDir: \"\",\n    async getTree(source) {\n        const initialRead = await fs.promises.readdir(source, {\n            withFileTypes: true,\n        });\n\n        return initialRead\n            .filter((dirent) => {\n                return (\n                    dirent.isDirectory() ||\n                    // We could support more than Markdown in the future.\n                    (dirent.isFile() && /\\.md$/.test(dirent.name))\n                );\n            })\n            .map(async (dirent) => {\n                if (dirent.isDirectory()) {\n                    self.currentDir += dirent.name;\n                    const subDirents = await Promise.all(\n                        await self.getTree(path.join(source, dirent.name))\n                    );\n                    return {\n                        directory: dirent.name,\n                        children: subDirents,\n                    };\n                } else {\n                    self.treePaths.push(`${self.currentDir}/${dirent.name}`);\n                    self.currentDir = \"\";\n\n                    return {\n                        file: dirent.name,\n                        exists: false,\n                    };\n                }\n            });\n    },\n    getAllFiles: (dirPath, arrayOfFiles) => {\n        const files = fs.readdirSync(dirPath);\n\n        arrayOfFiles = arrayOfFiles || [];\n\n        files.forEach(function (file) {\n            const filePath = `${dirPath}/${file}`;\n            if (fs.statSync(filePath).isDirectory()) {\n                arrayOfFiles = self.getAllFiles(filePath, arrayOfFiles);\n            } else if (/\\.md$/.test(file)) {\n                // arrayOfFiles.push(path.join(__dirname, dirPath, \"/\", file));\n                arrayOfFiles.push(filePath);\n            }\n        });\n\n        return arrayOfFiles;\n    },\n    async writeMaps(plainTextPath, maps) {\n        maps.tree = await Promise.all(await self.getTree(plainTextPath));\n        console.log(self.getAllFiles(plainTextPath));\n        // console.log(self.treePaths);\n        const dataMapPath = self.getDataMapPath(plainTextPath);\n        await fs.promises.mkdir(path.dirname(dataMapPath), { recursive: true });\n\n        await fs.promises.writeFile(dataMapPath, JSON.stringify(maps));\n    },\n\n    async importAll() {\n        const plainTextPath = self.getPlainTextPath();\n        const diskDataMap = await self.getDataMap(plainTextPath);\n        const db = inkdrop.main.dataStore.getLocalDB();\n\n        const tree = await Promise.all(await self.getTree(plainTextPath));\n        // console.log(self.treePaths);\n\n        await Promise.all(\n            Object.keys(diskDataMap.notes).map(async (noteId) => {\n                const newBody = await fs.promises.readFile(\n                    `${plainTextPath}/${diskDataMap.notes[noteId].path}`,\n                    \"utf-8\"\n                );\n\n                try {\n                    const currentNote = await db.notes.get(noteId);\n\n                    // Don't bother if there are no changes:\n                    if (currentNote.body !== newBody) {\n                        await db.notes.put({\n                            _id: noteId,\n                            _rev: currentNote._rev,\n                            updatedAt: Date.now(),\n                            bookId: currentNote.bookId,\n                            title: currentNote.title,\n                            doctype: currentNote.doctype,\n                            createdAt: currentNote.createdAt,\n\n                            body: newBody,\n                        });\n                    }\n                } catch (err) {\n                    console.warn(\n                        `${noteId} import from plain text failed!`,\n                        err\n                    );\n                }\n            })\n        );\n\n        db.dispose();\n    },\n});\n"],"file":"utilities.js"}