{"version":3,"sources":["../src/utilities.js"],"names":["self","module","exports","dataMap","books","notes","getBackupPath","inkdrop","config","get","core","db","backupPath","getPlainTextPath","getDataMapPath","plainTextPath","getNotePath","getDataMap","JSON","parse","fs","readFile","writeNote","notePath","body","mkdir","path","dirname","recursive","writeFile","getBookPath","disposable","doc","bookPath","name","parentBookId","hasParent","parentBookData","Boolean","getDataAndWriteAllNotes","allNotes","all","Promise","resolve","reject","docs","map","_id","title","bookData","bookId","writeMaps","maps","dataMapPath","stringify","importAll","diskDataMap","main","dataStore","getLocalDB","dirs","sourcePath","file","readdir","stat","join","isDirectory","console","log","Object","keys","noteId","newBody","currentNote","put","_rev","updatedAt","Date","now","doctype","createdAt","err","warn","dispose"],"mappings":";;AAAA;;AACA;;;;;;AAEA,MAAMA,IAAI,GAAIC,MAAM,CAACC,OAAP,GAAiB;AAC3BC,EAAAA,OAAO,EAAE;AAAEC,IAAAA,KAAK,EAAE,EAAT;AAAaC,IAAAA,KAAK,EAAE;AAApB,GADkB;;AAG3BC,EAAAA,aAAa,GAAG;AACZ,WAAOC,OAAO,CAACC,MAAR,CAAeC,GAAf,GAAqBC,IAArB,CAA0BC,EAA1B,CAA6BC,UAApC;AACH,GAL0B;;AAM3BC,EAAAA,gBAAgB,CAACD,UAAD,EAAa;AACzB,WAAQ,GAAEA,UAAU,IAAIZ,IAAI,CAACM,aAAL,EAAqB,aAA7C;AACH,GAR0B;;AAS3BQ,EAAAA,cAAc,CAACC,aAAD,EAAgB;AAC1B,WAAQ,GACJA,aAAa,IAAIf,IAAI,CAACa,gBAAL,EACpB,gDAFD;AAGH,GAb0B;;AAc3BG,EAAAA,WAAW,GAAG,CAAE,CAdW;;AAgB3B,QAAMC,UAAN,CAAiBF,aAAjB,EAAgC;AAC5B,WAAOG,IAAI,CAACC,KAAL,CACH,MAAMC,aAAGC,QAAH,CAAYrB,IAAI,CAACc,cAAL,CAAoBC,aAApB,CAAZ,EAAgD,MAAhD,CADH,CAAP;AAGH,GApB0B;;AAsB3B,QAAMO,SAAN,CAAgBC,QAAhB,EAA0BC,IAA1B,EAAgC;AAC5B,UAAMJ,aAAGK,KAAH,CAASC,IAAI,CAACC,OAAL,CAAaJ,QAAb,CAAT,EAAiC;AAAEK,MAAAA,SAAS,EAAE;AAAb,KAAjC,CAAN;AACA,UAAMR,aAAGS,SAAH,CAAaN,QAAb,EAAuBC,IAAvB,CAAN;AACH,GAzB0B;;AA0B3B,QAAMM,WAAN,CAAkBC,UAAlB,EAA8BC,GAA9B,EAAmC;AAC/B,QAAIC,QAAQ,GAAGD,GAAG,CAACE,IAAnB;;AACA,QAAIF,GAAG,CAACG,YAAR,EAAsB;AAClB,UAAIC,SAAS,GAAG,IAAhB;;AACA,aAAOA,SAAP,EAAkB;AACd,YAAIC,cAAc,GAAG,MAAMN,UAAU,CAAC3B,KAAX,CAAiBK,GAAjB,CACvB4B,cAAc,GACRA,cAAc,CAACF,YADP,GAERH,GAAG,CAACG,YAHa,CAA3B;AAKAF,QAAAA,QAAQ,GAAI,GAAEI,cAAc,CAACH,IAAK,IAAGD,QAAS,EAA9C;AACAG,QAAAA,SAAS,GAAGE,OAAO,CAACD,cAAc,CAACF,YAAhB,CAAnB;AACH;AACJ;;AACD,WAAOF,QAAP;AACH,GAzC0B;;AA0C3B,QAAMM,uBAAN,CAA8BR,UAA9B,EAA0ChB,aAA1C,EAAyD;AACrD;AACA,UAAMyB,QAAQ,GAAG,MAAMT,UAAU,CAAC1B,KAAX,CAAiBoC,GAAjB,EAAvB;AAEA,WAAO,IAAIC,OAAJ,CAAY,OAAOC,OAAP,EAAgBC,MAAhB,KAA2B;AAC1C,YAAMF,OAAO,CAACD,GAAR,CACF,MAAMD,QAAQ,CAACK,IAAT,CAAcC,GAAd,CAAkB,MAAOd,GAAP,IAAe;AACnC,YAAI,CAAChC,IAAI,CAACG,OAAL,CAAaE,KAAb,CAAmB2B,GAAG,CAACe,GAAvB,CAAL,EAAkC;AAC9B/C,UAAAA,IAAI,CAACG,OAAL,CAAaE,KAAb,CAAmB2B,GAAG,CAACe,GAAvB,IAA8B,EAA9B;AACH;;AACD/C,QAAAA,IAAI,CAACG,OAAL,CAAaE,KAAb,CAAmB2B,GAAG,CAACe,GAAvB,EAA4BC,KAA5B,GAAoChB,GAAG,CAACgB,KAAxC;AAEA,cAAMC,QAAQ,GAAG,MAAMlB,UAAU,CAAC3B,KAAX,CAAiBK,GAAjB,CAAqBuB,GAAG,CAACkB,MAAzB,CAAvB;;AAEA,YAAID,QAAJ,EAAc;AACV,cAAIhB,QAAQ,GAAG,MAAMjC,IAAI,CAAC8B,WAAL,CACjBC,UADiB,EAEjBkB,QAFiB,CAArB;AAKAjD,UAAAA,IAAI,CAACG,OAAL,CAAaC,KAAb,CAAmB4B,GAAG,CAACkB,MAAvB,IAAiCjB,QAAjC;AACAjC,UAAAA,IAAI,CAACG,OAAL,CAAaE,KAAb,CACI2B,GAAG,CAACe,GADR,EAEErB,IAFF,GAEU,GAAEO,QAAS,IAAGD,GAAG,CAACgB,KAAM,KAFlC;AAIA,gBAAMhD,IAAI,CAACsB,SAAL,CACD,GAAEP,aAAc,IACbf,IAAI,CAACG,OAAL,CAAaE,KAAb,CAAmB2B,GAAG,CAACe,GAAvB,EAA4BrB,IAC/B,EAHC,EAIFM,GAAG,CAACR,IAJF,CAAN;AAMH;AACJ,OA1BK,CADJ,CAAN;;AA6BA,UAAIxB,IAAI,CAACG,OAAT,EAAkB;AACdwC,QAAAA,OAAO,CAAC3C,IAAI,CAACG,OAAN,CAAP;AACH,OAFD,MAEO;AACHyC,QAAAA,MAAM,CAAC5C,IAAD,CAAN;AACH;AACJ,KAnCM,CAAP;AAoCH,GAlF0B;;AAmF3B,QAAMmD,SAAN,CAAgBpC,aAAhB,EAA+BqC,IAA/B,EAAqC;AACjC,UAAMC,WAAW,GAAGrD,IAAI,CAACc,cAAL,CAAoBC,aAApB,CAApB;AACA,UAAMK,aAAGK,KAAH,CAASC,IAAI,CAACC,OAAL,CAAa0B,WAAb,CAAT,EAAoC;AAAEzB,MAAAA,SAAS,EAAE;AAAb,KAApC,CAAN;AAEA,UAAMR,aAAGS,SAAH,CAAawB,WAAb,EAA0BnC,IAAI,CAACoC,SAAL,CAAeF,IAAf,CAA1B,CAAN;AACH,GAxF0B;;AA0F3B,QAAMG,SAAN,GAAkB;AACd,UAAMxC,aAAa,GAAGf,IAAI,CAACa,gBAAL,EAAtB;AACA,UAAM2C,WAAW,GAAG,MAAMxD,IAAI,CAACiB,UAAL,CAAgBF,aAAhB,CAA1B;AACA,UAAMJ,EAAE,GAAGJ,OAAO,CAACkD,IAAR,CAAaC,SAAb,CAAuBC,UAAvB,EAAX,CAHc,CAKd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAMC,IAAI,GAAG,MAAOC,UAAP,IAAsB;AAC/B,UAAID,IAAI,GAAG,EAAX;;AACA,WAAK,MAAME,IAAX,IAAmB,MAAM1C,aAAG2C,OAAH,CAAWF,UAAX,CAAzB,EAAiD;AAC7C,YACI,CAAC,MAAMzC,aAAG4C,IAAH,CAAQtC,IAAI,CAACuC,IAAL,CAAUJ,UAAV,EAAsBC,IAAtB,CAAR,CAAP,EAA6CI,WAA7C,EADJ,EAEE;AACEN,UAAAA,IAAI,GAAG,CAAC,GAAGA,IAAJ,EAAUE,IAAV,CAAP;AACH;AACJ;;AACD,aAAOF,IAAP;AACH,KAVD;;AAWAO,IAAAA,OAAO,CAACC,GAAR,CAAY,MAAMR,IAAI,CAAC7C,aAAD,CAAtB;AACA;AAEA,UAAM2B,OAAO,CAACD,GAAR,CACF4B,MAAM,CAACC,IAAP,CAAYd,WAAW,CAACnD,KAAxB,EAA+ByC,GAA/B,CAAmC,MAAOyB,MAAP,IAAkB;AACjD,YAAMC,OAAO,GAAG,MAAMpD,aAAGC,QAAH,CACjB,GAAEN,aAAc,IAAGyC,WAAW,CAACnD,KAAZ,CAAkBkE,MAAlB,EAA0B7C,IAAK,EADjC,EAElB,MAFkB,CAAtB;;AAKA,UAAI;AACA,cAAM+C,WAAW,GAAG,MAAM9D,EAAE,CAACN,KAAH,CAASI,GAAT,CAAa8D,MAAb,CAA1B,CADA,CAGA;;AACA,YAAIE,WAAW,CAACjD,IAAZ,KAAqBgD,OAAzB,EAAkC;AAC9B,gBAAM7D,EAAE,CAACN,KAAH,CAASqE,GAAT,CAAa;AACf3B,YAAAA,GAAG,EAAEwB,MADU;AAEfI,YAAAA,IAAI,EAAEF,WAAW,CAACE,IAFH;AAGfC,YAAAA,SAAS,EAAEC,IAAI,CAACC,GAAL,EAHI;AAIf5B,YAAAA,MAAM,EAAEuB,WAAW,CAACvB,MAJL;AAKfF,YAAAA,KAAK,EAAEyB,WAAW,CAACzB,KALJ;AAMf+B,YAAAA,OAAO,EAAEN,WAAW,CAACM,OANN;AAOfC,YAAAA,SAAS,EAAEP,WAAW,CAACO,SAPR;AASfxD,YAAAA,IAAI,EAAEgD;AATS,WAAb,CAAN;AAWH;AACJ,OAjBD,CAiBE,OAAOS,GAAP,EAAY;AACVd,QAAAA,OAAO,CAACe,IAAR,CACK,GAAEX,MAAO,iCADd,EAEIU,GAFJ;AAIH;AACJ,KA7BD,CADE,CAAN;AAiCAtE,IAAAA,EAAE,CAACwE,OAAH;AACH;;AApM0B,CAA/B","sourcesContent":["import { promises as fs } from \"fs\";\nimport * as path from \"path\";\n\nconst self = (module.exports = {\n    dataMap: { books: {}, notes: {} },\n\n    getBackupPath() {\n        return inkdrop.config.get().core.db.backupPath;\n    },\n    getPlainTextPath(backupPath) {\n        return `${backupPath || self.getBackupPath()}/PLAIN_TEXT`;\n    },\n    getDataMapPath(plainTextPath) {\n        return `${\n            plainTextPath || self.getPlainTextPath()\n        }/.inkdrop_plain_text_backups/__DATA_MAP__.json`;\n    },\n    getNotePath() {},\n\n    async getDataMap(plainTextPath) {\n        return JSON.parse(\n            await fs.readFile(self.getDataMapPath(plainTextPath), \"utf8\")\n        );\n    },\n\n    async writeNote(notePath, body) {\n        await fs.mkdir(path.dirname(notePath), { recursive: true });\n        await fs.writeFile(notePath, body);\n    },\n    async getBookPath(disposable, doc) {\n        let bookPath = doc.name;\n        if (doc.parentBookId) {\n            let hasParent = true;\n            while (hasParent) {\n                var parentBookData = await disposable.books.get(\n                    parentBookData\n                        ? parentBookData.parentBookId\n                        : doc.parentBookId\n                );\n                bookPath = `${parentBookData.name}/${bookPath}`;\n                hasParent = Boolean(parentBookData.parentBookId);\n            }\n        }\n        return bookPath;\n    },\n    async getDataAndWriteAllNotes(disposable, plainTextPath) {\n        // Sync everything one time:\n        const allNotes = await disposable.notes.all();\n\n        return new Promise(async (resolve, reject) => {\n            await Promise.all(\n                await allNotes.docs.map(async (doc) => {\n                    if (!self.dataMap.notes[doc._id]) {\n                        self.dataMap.notes[doc._id] = {};\n                    }\n                    self.dataMap.notes[doc._id].title = doc.title;\n\n                    const bookData = await disposable.books.get(doc.bookId);\n\n                    if (bookData) {\n                        let bookPath = await self.getBookPath(\n                            disposable,\n                            bookData\n                        );\n\n                        self.dataMap.books[doc.bookId] = bookPath;\n                        self.dataMap.notes[\n                            doc._id\n                        ].path = `${bookPath}/${doc.title}.md`;\n\n                        await self.writeNote(\n                            `${plainTextPath}/${\n                                self.dataMap.notes[doc._id].path\n                            }`,\n                            doc.body\n                        );\n                    }\n                })\n            );\n            if (self.dataMap) {\n                resolve(self.dataMap);\n            } else {\n                reject(self);\n            }\n        });\n    },\n    async writeMaps(plainTextPath, maps) {\n        const dataMapPath = self.getDataMapPath(plainTextPath);\n        await fs.mkdir(path.dirname(dataMapPath), { recursive: true });\n\n        await fs.writeFile(dataMapPath, JSON.stringify(maps));\n    },\n\n    async importAll() {\n        const plainTextPath = self.getPlainTextPath();\n        const diskDataMap = await self.getDataMap(plainTextPath);\n        const db = inkdrop.main.dataStore.getLocalDB();\n\n        // let allDirectories = [];\n        // const getDirectories = async (baseDir) => {\n        //     console.log(baseDir);\n        //     const directories = await fs.readdir(baseDir, {\n        //         withFileTypes: true,\n        //     });\n        //     console.log(directories);\n        //     debugger;\n        //     await Promise.all(\n        //         directories.map(async (dir) => {\n        //             allDirectories.push(\n        //                 await getDirectories(path.join(baseDir, dir.name))\n        //             );\n        //         })\n        //     );\n        //     console.log(allDirectories);\n        //     debugger;\n\n        //     // const allDirectories = directories\n        //     //     .filter((dir) => dir.isDirectory())\n        //     //     .map((dir) => {\n        //     //         const dirPath = path.join(baseDir, dir.name);\n        //     //         // const relativePath = path.join(base, file.name);\n        //     //         // debugger;\n        //     //         // console.log(\"dirs:\");\n        //     //         // console.log(dirs);\n        //     //         if (dir.isDirectory()) {\n        //     //             return getDirectories(dirPath);\n        //     //         } else {\n        //     //             return dirPath;\n        //     //         }\n        //     //         //  else if (file.isFile()) {\n        //     //         //     file.__fullPath = filePath;\n        //     //         //     // file.__relateivePath = relativePath;\n        //     //         //     return files.concat(file);\n        //     //         // }\n        //     //     });\n        //     // console.log(allDirectories);\n        //     return allDirectories;\n        // };\n\n        // const getDirectories = async (source) => {\n        //     const allDirectories = await fs.readdir(source, {\n        //         withFileTypes: true,\n        //     });\n\n        //     return allDirectories\n        //         .filter((dirent) => dirent.isDirectory())\n        //         .map((dirent) => dirent.name);\n        // };\n        // const allDirectories = await getDirectories(plainTextPath);\n        // console.log(allDirectories);\n\n        const dirs = async (sourcePath) => {\n            let dirs = [];\n            for (const file of await fs.readdir(sourcePath)) {\n                if (\n                    (await fs.stat(path.join(sourcePath, file))).isDirectory()\n                ) {\n                    dirs = [...dirs, file];\n                }\n            }\n            return dirs;\n        };\n        console.log(await dirs(plainTextPath));\n        debugger;\n\n        await Promise.all(\n            Object.keys(diskDataMap.notes).map(async (noteId) => {\n                const newBody = await fs.readFile(\n                    `${plainTextPath}/${diskDataMap.notes[noteId].path}`,\n                    \"utf8\"\n                );\n\n                try {\n                    const currentNote = await db.notes.get(noteId);\n\n                    // Don't bother if there are no changes:\n                    if (currentNote.body !== newBody) {\n                        await db.notes.put({\n                            _id: noteId,\n                            _rev: currentNote._rev,\n                            updatedAt: Date.now(),\n                            bookId: currentNote.bookId,\n                            title: currentNote.title,\n                            doctype: currentNote.doctype,\n                            createdAt: currentNote.createdAt,\n\n                            body: newBody,\n                        });\n                    }\n                } catch (err) {\n                    console.warn(\n                        `${noteId} import from plain text failed!`,\n                        err\n                    );\n                }\n            })\n        );\n\n        db.dispose();\n    },\n});\n"],"file":"utilities.js"}